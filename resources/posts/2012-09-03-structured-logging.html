<article comments="1">
  <title>Structured Logging</title>
  <date>2012-09-04 13:25</date>
  <tags>
    <tag>Technology</tag>
  </tags>
</article>

<summary>
  <p>
    A few weeks ago, I decided to cease my involvement in
    the <a href="https://fedorahosted.org/lumberjack/">lumberjack</a>
    and <a href="http://cee.mitre.org/">CEE</a> projects (although, my
    involvement in the latter was more an interest than involvement),
    because as it turns out, neither will fulfill my logging needs. In
    this post, I will try to explain why.
  </p>
</summary>

<section>

  <p>
    When I write a program, I try to pay great attention to logging,
    that the logs my application emits will be useful: they should
    contain all the information the application does at that point, in
    a format that is easy to produce, and easy to work with too. To
    understand my requirements, let me first explain how my recent
    applications are built, and how their logging works.
  </p>

  <p>
    For the sake of this example, lets take the backend of a
    web-facing application, one that has a REST API, knows about user
    sessions and a whole lot more. In this case, whenever a request
    arrives, I want to know where the request came from, which session
    and user it belongs to, what the request was, and what response we
    gave, which layers it traversed through during the process, what
    application and which instance of it produced the message.
  </p>

  <p>
    In short: I don't want a <em>separate</em> log entry for each
    step, I want one event for the whole deal, with the combined
    information from all layers of my application. For this, I need a
    structure if I want to handle it sanely and effortlessly: each
    layer will work in its own namespace.
  </p>

  <p>
    I achieve this by having a request-specific <em>state</em> that
    goes through the layers, and each one can transform it in whatever
    way it sees fit. In the end, I'll just filter out a couple of
    unimportant parts, and dump the end state to the logging
    facility. Would I want to debug it further, I can dump each
    version of this state at each transformation point, and still be
    able to bind it together when querying my logs.
  </p>

  <p>
    To make it clear how this all looks like, lets assume the
    following scenario: a logged in user (lets call him <em>Joe</em>)
    attempts to access the <code>/api/stuff/</code> URI using
    a <em>GET</em> request, requesting <em>JSON</em> response (via
    the <code>Accept</code> header). This particular URI will list
    some stuff available to the user, in our case, this will succeed,
    and return 6 items.
  </p>

  <p>
    When the request arrives, the framework I use will parse the HTTP
    request, pass it through a couple of middleware, including one
    that parses cookies. By the time the request arrives to my own
    function, the state is already looking something like the
    following:
  </p>

  <div class="pygmentize" data-language="clojure">{:request {:request-method "GET",
           :remote-ip "127.0.0.1",
           :uri "/api/stuff/",
           :accept ["application/json"],
           :cookies {:username {:value "Joe",
                                :path "/",
                                :domain "example.org"},
                     :session-id {:value "dead-beef",
                                  :path "/",
                                  :domain "example.org"}}
           :id "1234",
           :timestamp "2012-09-04T11:52:00.0000+00:00Z"}}</div>

  <p>
    Once this arrives to my own handler function, that will add its
    own stuff to the <code>:api</code> namespace. It will store what
    action it performed, and not much else: if it reaches down to a
    database, then another function will add that, under its own
    namespace; the response itself will be generated by the response
    layer, which will add its own notes too. In the end, just before
    returning the response, we'll end up with the following added to
    the state above:
  </p>

  <div class="pygmentize" data-language="clojure">{:my-application {:stuff {:action "list",
                          :items 6},
                  :instance "node-1",
                  :timestamp "2012-09-04T11:52:00.0008+00:00Z"},
 :response {:status 200,
            :content-type "application/json",
            :content-length 500,
            :timestamp "2012-09-04T11:52:00.0010+00:00Z"}}</div>

  <p>
    If I simply take this state, and store it, I can immediately
    construct a query that returns me all sessions that took longer
    than 10 milliseconds to serve. I can further limit that to only
    display the unique application instances where this happened, and
    perhaps even limit it to the last 10 minutes, and only successful
    responses.
  </p>

  <p>
    Granted, I could do that without nested structures, but that would
    make the query more expensive, it would use more bandwidth on the
    wire, and I would need to transform my internal representation of
    state to something inferior, either on the application side or on
    a relay or something similar. In either case, flattening would
    result in more work being done without any noticable benefit.
  </p>

  <p>
    Since CEE decided to use a flat structure, I will not be able to
    use it, because that would mean I have to dumb down my logging. I
    hate dumbing down useful things, so I will simply not do that. I
    like that each layer of my application can work in its own little
    namespace, that the data I have is represented in the same manner
    as it is natural: structured.
  </p>

  <p>
    Thing is, my applications do not explicitly log, either. They have
    states, and I'm able to dump that state at whatever point I feel
    it is necessary. This is efficient, and very, very convenient. As
    such, my state dumps, my logs look very much like my applications
    internal state. This is terrific in quite a many ways:
  </p>

  <dl>
    <dt>It eases debugging</dt>
    <dd>
      Because the application has similar internal data structures as
      the logs, it becomes considerably easier to connect the two and
      in case of problems, reason out where and what went
      wrong. Furthermore, when I attach a REPL to the application, and
      inspect the state, it will look exactly like my logs. If I
      enable tracing, I will see each version of the state, and will
      be able to see where it went wrong, just by looking at the data.
    </dd>

    <dt>It makes indexing and storage simple</dt>
    <dd>
      My logs are already produced in a format that is suitable for
      both storing in a database (for
      example, <a href="http://couchdb.apache.org/">CouchDB</a>), and
      for indexing
      (via <a href="http://www.elasticsearch.org/">ElasticSearch</a>),
      there is very little work I need to do to make these logs easy
      to query.
    </dd>

    <dt>Dumping state cuts down development time</dt>
    <dd>
      <p>
        Since I do not explicitly log, but dump state instead, there
        is little to no effort I need to put into making my logs
        useful: my application state is already useful, otherwise the
        program wouldn't work properly. I don't need to come up with
        suitable log messages that explain the problem: I can deduce
        all that from state or state change.
      </p>

      <p>
        All I need to do to change what gets logged, is changing which
        functions are hooked. Lets assume I have a function
        called <code>list</code> in the <code>api</code> namespace,
        and I want to dump the state there.
      </p>

      <div class="pygmentize" data-language="clojure">(add-hook #'api/list #'log/dump-state)</div>

      <p>
        And that's about it. I can just fire up a REPL, and
        interactively add a hook if I need to debug. I can do this as
        part of the configuration, and in many other ways as well.
      </p>
    </dd>
  </dl>

  <p>
    In the programming world, we learned it long ago, that structure
    matters, that it makes things considerably easier to work with,
    and to understand. Data - and therefore logs - are similar. Yet,
    while our data is often neatly structured, our logs rarely are,
    and any effort that does not move towards more structure is - in
    my opinion - a failure. A flat structure is about as useful as a
    BASIC program from 30 years ago. It would be high time we realized
    that log structure matters, it does not complicate logs: it
    simplifies them! Therefore, we should not be afraid of them, but
    embrace it, like we did for programming. Data is - after all - not
    much different.
  </p>

  <div class="span12">
    <div class="span6">
      <blockquote class="pull-right">
        "Data is just dumb code, and code is just smart data."

        <p>
          &mdash;
          <cite>
            <a href="http://mitpress.mit.edu/sicp/">Structure and
              Interpretation of Computer Programs</a>
          </cite>
        </p>
      </blockquote>
    </div>
  </div>

</section>
